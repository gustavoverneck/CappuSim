<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains OpenCL kernels for implementing the Lattice Boltzmann Method (LBM). The kernels include functionality for streaming, collision, equilibrium computation, and copying data between distribution function arrays."><title>LBM_KERNEL in lattelab::core::kernels - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="lattelab" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../lattelab/index.html">lattelab</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">LBM_<wbr>KERNEL</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#kernels" title="Kernels">Kernels</a><ul><li><a href="#streaming_kernel" title="`streaming_kernel`"><code>streaming_kernel</code></a></li><li><a href="#collision_kernel" title="`collision_kernel`"><code>collision_kernel</code></a></li><li><a href="#swap" title="`swap`"><code>swap</code></a></li><li><a href="#equilibrium" title="`equilibrium`"><code>equilibrium</code></a></li></ul></li><li><a href="#notes" title="Notes">Notes</a></li><li><a href="#usage" title="Usage">Usage</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In lattelab::<wbr>core::<wbr>kernels</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">lattelab</a>::<wbr><a href="../index.html">core</a>::<wbr><a href="index.html">kernels</a></span><h1>Constant <span class="constant">LBM_KERNEL</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/lattelab/core/kernels.rs.html#60-291">Source</a> </span></div><pre class="rust item-decl"><code>pub const LBM_KERNEL: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.str.html">str</a> = r#&quot;
// Velocity vectors (D2Q9, D3Q7, D3Q15, D3Q19, D3Q27)
constant int c[Q][3] = {
#if defined(D2Q9)
    {0, 0, 0}, {1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0},
    {1, 1, 0}, {-1, -1, 0}, {1, -1, 0}, {-1, 1, 0}
#elif defined(D3Q7)
    {0, 0, 0}, {1, 0, 0}, {-1, 0, 0}, {0, 1, 0},
    {0, -1, 0}, {0, 0, 1}, {0, 0, -1}
#elif defined(D3Q15)
    {0, 0, 0}, {1, 0, 0}, {-1, 0, 0}, {0, 1, 0},
    {0, -1, 0}, {0, 0, 1}, {0, 0, -1}, {1, 1, 1},
    {-1, -1, -1}, {1, 1, -1}, {-1, -1, 1}, {1, -1, 1},
    {-1, 1, -1}, {-1, 1, 1}, {1, -1, -1}
#elif defined(D3Q19)
    {0, 0, 0}, {1, 0, 0}, {-1, 0, 0}, {0, 1, 0},
    {0, -1, 0}, {0, 0, 1}, {0, 0, -1}, {1, 1, 0},
    {-1, -1, 0}, {1, 0, 1}, {-1, 0, -1}, {0, 1, 1},
    {0, -1, -1}, {1, -1, 0}, {-1, 1, 0}, {1, 0, -1},
    {-1, 0, 1}, {0, 1, -1}, {0, -1, 1}
#elif defined(D3Q27)
    {0, 0, 0}, {1, 0, 0}, {-1, 0, 0}, {0, 1, 0},
    {0, -1, 0}, {0, 0, 1}, {0, 0, -1}, {1, 1, 0},
    {-1, -1, 0}, {1, 0, 1}, {-1, 0, -1}, {0, 1, 1},
    {0, -1, -1}, {1, -1, 0}, {-1, 1, 0}, {1, 0, -1},
    {-1, 0, 1}, {0, 1, -1}, {0, -1, 1}, {1, 1, 1},
    {-1, -1, -1}, {1, 1, -1}, {-1, -1, 1}, {1, -1, 1},
    {-1, 1, -1}, {-1, 1, 1}, {1, -1, -1}
#endif
};

constant int opposite[Q] = {
#if defined(D2Q9)
    0, 2, 1, 4, 3, 6, 5, 8, 7
#elif defined(D3Q7)
    0, 2, 1, 4, 3, 6, 5
#elif defined(D3Q15)
    0, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13
#elif defined(D3Q19)
    0, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15, 18, 17
#elif defined(D3Q27)
    0, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15, 18, 17, 20, 19, 22, 21, 24, 23, 26, 25
#endif
};

constant float w[Q] = {
#if defined(D2Q9)
    4.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0,
    1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0
#elif defined(D3Q7)
    1.0/4.0, 1.0/8.0, 1.0/8.0, 1.0/8.0, 1.0/8.0, 1.0/8.0, 1.0/8.0
#elif defined(D3Q15)
    2.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0,
    1.0/9.0, 1.0/9.0, 1.0/72.0, 1.0/72.0, 1.0/72.0,
    1.0/72.0, 1.0/72.0, 1.0/72.0, 1.0/72.0, 1.0/72.0
#elif defined(D3Q19)
    1.0/3.0, 1.0/18.0, 1.0/18.0, 1.0/18.0, 1.0/18.0,
    1.0/18.0, 1.0/18.0, 1.0/36.0, 1.0/36.0, 1.0/36.0,
    1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0,
    1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0
#elif defined(D3Q27)
    8.0/27.0, 2.0/27.0, 2.0/27.0, 2.0/27.0, 2.0/27.0,
    2.0/27.0, 2.0/27.0, 1.0/54.0, 1.0/54.0, 1.0/54.0,
    1.0/54.0, 1.0/54.0, 1.0/54.0, 1.0/54.0, 1.0/54.0,
    1.0/54.0, 1.0/54.0, 1.0/54.0, 1.0/54.0, 1.0/216.0,
    1.0/216.0, 1.0/216.0, 1.0/216.0, 1.0/216.0, 1.0/216.0,
    1.0/216.0, 1.0/216.0
#endif
};

// ----------------------------------------------------------------------------------------------------------------------

__kernel void streaming_kernel(
    __global float* f,        // Input distribution function
    __global float* f_new,    // Output distribution function after streaming
    __global int* flags       // Flags: FLUID, SOLID, EQ
) {
    // Get the global ID of the current thread
    int n = get_global_id(0); 
    if (n &gt;= NX * NY * NZ) return; // Prevent out-of-bounds access

    // Skip processing for solid cells
    if (flags[n] == FLAG_SOLID) return;

    // Compute the 3D coordinates of the current cell
    int x = n % NX;
    int y = (n / NX) % NY;
    int z = n / (NX * NY);

    // Loop over all velocity directions
    #pragma unroll
    for (int q = 0; q &lt; Q; q++) {
        // Get the velocity vector components for the current direction
        int dx = c[q][0];
        int dy = c[q][1];
        int dz = c[q][2];

        // Compute the coordinates of the neighboring cell, applying periodic boundary conditions
        int xn = (x + dx + NX) % NX;
        int yn = (y + dy + NY) % NY;
        int zn = (z + dz + NZ) % NZ;

        // Compute the linear index of the neighboring cell
        int nn = zn * (NX * NY) + yn * NX + xn;

        // Retrieve the flag of the neighboring cell
        int neighbor_flag = flags[nn];

        if (neighbor_flag == FLAG_SOLID) {
            // Bounce-back condition: reflect to the opposite direction within the current cell
            f_new[n * Q + opposite[q]] = f[n * Q + q];
        }
        else if (neighbor_flag == FLAG_FLUID || neighbor_flag == FLAG_EQ) {
            // Propagate to the neighboring cell (includes safe periodicity)
            f_new[nn * Q + q] = f[n * Q + q];
        }
    }
}

// ----------------------------------------------------------------------------------------------------------------------

__kernel void collision_kernel(
    __global float* f,        // Input distribution function array
    __global float* rho,      // Output density array
    __global int* flags,      // Flags array indicating boundary conditions
    __global float* u,        // Output velocity array
    float omega               // Relaxation parameter
) {
    // Get the global ID of the current thread
    int n = get_global_id(0);
    if (n &gt;= N) return; // Prevent out-of-bounds access

    // Retrieve the flag for the current cell
    int flag = flags[n];

    // Skip collision for solid cells
    if (flag == FLAG_SOLID) return;

    // Compute local density and velocity
    float local_rho = 0.0f;
    float ux = 0.0f, uy = 0.0f, uz = 0.0f;

    // Loop over all velocity directions to calculate density and velocity
    #pragma unroll
    for (int q = 0; q &lt; Q; q++) {
        float fq = f[n * Q + q];
        local_rho += fq;                  // Accumulate density
        ux += c[q][0] * fq;               // Accumulate x-velocity
        uy += c[q][1] * fq;               // Accumulate y-velocity
        uz += c[q][2] * fq;               // Accumulate z-velocity
    }

    // Normalize velocity by density, avoiding division by zero
    float inv_rho = (local_rho &gt; 1e-10f) ? 1.0f / local_rho : 0.0f;
    ux *= inv_rho;
    uy *= inv_rho;
    uz *= inv_rho;

    // Store macroscopic variables (density and velocity)
    rho[n] = local_rho;
    u[n * 3 + 0] = ux;
    u[n * 3 + 1] = uy;
    u[n * 3 + 2] = uz;

    float u2 = ux * ux + uy * uy + uz * uz;                // Squared velocity magnitude

    if (flag == FLAG_EQ) {
        #pragma unroll    
        for (int q = 0; q &lt; Q; q++) {
            float cu = c[q][0] * ux + c[q][1] * uy + c[q][2] * uz; // Dot product of velocity and direction vector
            f[n * Q + q] = local_rho * w[q] * (1.0f + 3.0f * cu + 4.5f * cu * cu - 1.5f * u2); // Equilibrium distribution
        }  
    } else {
        // Perform standard BGK collision for fluid cells
        #pragma unroll
        for (int q = 0; q &lt; Q; q++) {
            float cu = c[q][0] * ux + c[q][1] * uy + c[q][2] * uz; // Dot product of velocity and direction vector
            float feq = local_rho * w[q] * (1.0f + 3.0f * cu + 4.5f * cu * cu - 1.5f * u2); // Equilibrium distribution
            f[n * Q + q] = (1.0f - omega) * f[n * Q + q] + omega * feq; // Relaxation towards equilibrium
        }
    }
}


// ----------------------------------------------------------------------------------------------------------------------

// Kernel to swap data from the new distribution function array to the original array
__kernel void swap(__global float* f, __global float* f_new) {
    // Get the global ID of the current thread
    int n = get_global_id(0);

    // Prevent out-of-bounds access
    if (n &gt;= N * Q) return;

    // Copy the value from the new distribution function array to the original array
    f[n] = f_new[n];
}

// ----------------------------------------------------------------------------------------------------------------------

__kernel void equilibrium(
    __global float* f,        // Distribution function array
    __global float* rho,      // Density array
    __global float* u         // Velocity array
) {
    // Get the global ID of the current thread
    int n = get_global_id(0);
    if (n &gt;= N) return; // Prevent out-of-bounds access

    // Retrieve velocity components for the current node
    float ux = u[n * 3];
    float uy = u[n * 3 + 1];
    float uz = u[n * 3 + 2];
    
    // Compute the squared velocity magnitude
    float u2 = ux * ux + uy * uy + uz * uz;

    // Retrieve the local density for the current node
    float local_rho = rho[n];

    // Loop over all velocity directions
    #pragma unroll
    for (int q = 0; q &lt; Q; q++) {
        // Compute the dot product of velocity and direction vector
        float cu = c[q][0] * ux + c[q][1] * uy + c[q][2] * uz;

        // Compute the equilibrium distribution function for the current direction
        f[n * Q + q] = local_rho * w[q] * (1.0f + 3.0f * cu + 4.5f * cu * cu - 1.5f * u2);
    }
}
// ----------------------------------------------------------------------------------------------------------------------
&quot;#;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains OpenCL kernels for implementing the Lattice Boltzmann Method (LBM).
The kernels include functionality for streaming, collision, equilibrium computation,
and copying data between distribution function arrays.</p>
<h2 id="constants"><a class="doc-anchor" href="#constants">§</a>Constants</h2>
<ul>
<li><code>c</code>: Velocity vectors for different lattice configurations (D2Q9, D3Q7, D3Q15, D3Q19, D3Q27).</li>
<li><code>opposite</code>: Opposite direction indices for bounce-back boundary conditions.</li>
<li><code>w</code>: Weight factors for equilibrium distribution computation.</li>
</ul>
<h2 id="kernels"><a class="doc-anchor" href="#kernels">§</a>Kernels</h2><h3 id="streaming_kernel"><a class="doc-anchor" href="#streaming_kernel">§</a><code>streaming_kernel</code></h3>
<p>Performs the streaming step of the LBM. It streams the distribution function values
to neighboring nodes based on velocity vectors. Handles boundary conditions using
bounce-back for solid nodes.</p>
<h4 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters:</h4>
<ul>
<li><code>f</code>: Input distribution function array.</li>
<li><code>f_new</code>: Output distribution function array after streaming.</li>
<li><code>flags</code>: Flags array indicating boundary conditions.</li>
</ul>
<h3 id="collision_kernel"><a class="doc-anchor" href="#collision_kernel">§</a><code>collision_kernel</code></h3>
<p>Performs the collision step of the LBM. It computes the local density and velocity,
applies boundary conditions, and relaxes the distribution function towards equilibrium.</p>
<h4 id="parameters-1"><a class="doc-anchor" href="#parameters-1">§</a>Parameters:</h4>
<ul>
<li><code>f</code>: Input distribution function array.</li>
<li><code>rho</code>: Output density array.</li>
<li><code>flags</code>: Flags array indicating boundary conditions.</li>
<li><code>u</code>: Output velocity array.</li>
<li><code>omega</code>: Relaxation parameter.</li>
</ul>
<h3 id="swap"><a class="doc-anchor" href="#swap">§</a><code>swap</code></h3>
<p>Copies data from the new distribution function array to the original array.</p>
<h4 id="parameters-2"><a class="doc-anchor" href="#parameters-2">§</a>Parameters:</h4>
<ul>
<li><code>f</code>: Original distribution function array.</li>
<li><code>f_new</code>: New distribution function array to copy from.</li>
</ul>
<h3 id="equilibrium"><a class="doc-anchor" href="#equilibrium">§</a><code>equilibrium</code></h3>
<p>Computes the equilibrium distribution function for each node based on local density
and velocity.</p>
<h4 id="parameters-3"><a class="doc-anchor" href="#parameters-3">§</a>Parameters:</h4>
<ul>
<li><code>f</code>: Distribution function array.</li>
<li><code>rho</code>: Density array.</li>
<li><code>u</code>: Velocity array.</li>
</ul>
<h2 id="notes"><a class="doc-anchor" href="#notes">§</a>Notes</h2>
<ul>
<li>The kernels are designed to work with different lattice configurations, such as D2Q9, D3Q7, D3Q15, D3Q19, and D3Q27.</li>
<li>Periodic boundary conditions are applied during the streaming step.</li>
<li>Bounce-back boundary conditions are implemented for solid nodes.</li>
<li>The collision kernel supports both standard BGK collision and equilibrium initialization for specific nodes.</li>
<li>The equilibrium kernel computes the equilibrium distribution function directly for given density and velocity values.</li>
</ul>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p>These kernels are written in OpenCL C and are intended to be used with an OpenCL runtime.
They are embedded as a string in the Rust code and can be compiled and executed on compatible devices.</p>
</div></details></section></div></main></body></html>